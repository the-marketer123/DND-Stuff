<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DnD Manager</title>
    <!-- p5.js -->
    <script src="https://cdn.jsdelivr.net/npm/p5@1.11.8/lib/p5.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.11.8/lib/addons/p5.sound.min.js"></script>
    <style>
        html, body {
        margin: 0;
        padding: 0;
        }
        canvas {
        display: block;
        }
    </style>
</head>
<body>
    <script>

        /* Prerequisites */
            let uiCanvas;
            let user;

            function setup() {
            uiCanvas = createCanvas(windowWidth, windowHeight).elt;

            user = (function (controls) {
                controls.mX = controls.mY = 0;
                controls.mP = controls.mC = false;
                controls.kH = {};
                controls.kC = {};

                uiCanvas.onmousemove = function (e) {
                controls.mX = e.offsetX;
                controls.mY = e.offsetY;
                };

                uiCanvas.onmousedown = function () {
                if (!controls.mP) controls.mC = true;
                controls.mP = true;
                };

                uiCanvas.onmouseup = function () {
                controls.mP = false;
                };

                document.onkeydown = function (e) {
                const key = normalizeKey(e);
                if (controls.kH[key] !== true) {
                    controls.kC[key] = true;
                } else {
                    controls.kC[key] = false;
                }
                controls.kH[key] = true;
                };

                document.onkeyup = function (e) {
                const key = normalizeKey(e);
                controls.kH[key] = false;
                };

                controls.update = function () {
                controls.kC = {};
                controls.mC = false;
                };

                function normalizeKey(e) {
                if (e.key.length === 1) {
                    return e.key.toLowerCase(); // letters & symbols
                }
                return e.key; // keep ArrowUp, Shift, Enter, etc.
                }

                return controls;
            })({});
            }
        /* Rest */
        
        let menu = {
            show:false,
            prevState:false,
            button: {
                x:5,
                y:5,
                draw: function (x=0, y=0) {
                    x += this.x;
                    y += this.y;
                    strokeWeight(2.5);
                    fill(150, 150, 150);
                    rect(0 + x, 0 + y, 50, 50, 5);
                    fill(0, 0, 0);
                    strokeWeight(2.5);
                    line(10 + x, 15 + y, 40 + x, 15 + y);
                    line(10 + x, 25 + y, 40 + x, 25 + y);
                    line(10 + x, 35 + y, 40 + x, 35 + y);
                },
                update: function () {
                    // Adjust mouse position so it matches the translated menu
                    let mouseXAdj = user.mX - window.scrollX;
                    let mouseYAdj = user.mY - window.scrollY;

                    let click = (
                        mouseXAdj >= this.x && mouseXAdj <= this.x + 50 &&
                        mouseYAdj >= this.y && mouseYAdj <= this.y + 50 &&
                        user.mC
                    );

                    if (click) {
                        menu.show = !menu.show;
                    }
                }

            },
            // Add a property to track the current x position of the menu panel
            panelX: -200, // start hidden
            update: function () {
                // Counteract page scroll so menu always stays visible
                push();
                translate(window.scrollX, window.scrollY);

                // Target x position for the menu panel
                let targetX = this.show ? 0 : -200;
                this.panelX += (targetX - this.panelX) * 0.2;

                // Draw the menu panel
                fill(200, 200, 240);
                rect(this.panelX - 5, -5, 205, windowHeight + 10, 5);
                this.button.x = this.panelX + 205;
                this.button.y = 5;

                // options text
                textSize(20);                
                strokeWeight(1);
                stroke(0, 0, 0);
                fill(100, 100, 0);
                text("menu", this.panelX + 72, 42);
                fill(0, 0, 0);
                text("menu", this.panelX + 70, 40);


                textAlign(LEFT, TOP);
                strokeWeight(3);
                fill(200, 200, 240);
                stroke(100, 100, 0);
                rect(this.panelX + 17, 87, 173, 30, 5);
                stroke(0, 0, 0);
                rect(this.panelX + 15, 85, 173, 30, 5);

                strokeWeight(1);
                fill(100, 100, 0);
                text("Character Tracker", this.panelX + 22, 92);
                fill(0, 0, 0);
                text("Character Tracker", this.panelX + 20, 90);



                fill(200,200,240);
                strokeWeight(3);
                stroke(100,100,0);
                rect(this.panelX + 17, 137, 173, 30, 5);
                stroke(0,0,0);
                rect(this.panelX + 15, 135, 173, 30, 5);

                textAlign(LEFT, TOP);
                textSize(20);
                strokeWeight(1);
                fill(100,100,0);
                text("nothin else yet", this.panelX + 27, 142);
                fill(0,0,0);
                text("nothin else yet", this.panelX + 25, 140);
           
                // draw button
                this.button.draw();
                this.button.update();

                pop();
            },

        }
        let activeEdit = null; // {charIndex, field, x, y, w, h}
        let inputBox = null;
        function startEditing(charIndex, field, x, y, w, h, initialValue) {
            if (inputBox) inputBox.remove(); // clear old input
            inputBox = document.createElement("input");
            inputBox.type = "text";
            inputBox.value = initialValue;
            inputBox.style.position = "absolute";
            inputBox.style.left = (x + window.scrollX) + "px";
            inputBox.style.top = (y + window.scrollY) + "px";
            inputBox.style.width = w + "px";
            inputBox.style.fontSize = "16px";
            document.body.appendChild(inputBox);
            inputBox.focus();

            activeEdit = {charIndex, field};

            inputBox.onblur = () => {
                commitEdit();
            };
            inputBox.onkeydown = (e) => {
                if (e.key === "Enter") {
                    commitEdit();
                }
            };
        }

        function commitEdit() {
            if (!activeEdit || !inputBox) return;
            let val = inputBox.value;
            let char = scenes.list[0].handler.chars[activeEdit.charIndex];

            // update right field
            char[activeEdit.field] = (isNaN(val) ? val : Number(val)); 
            // smart-cast numbers

            inputBox.remove();
            inputBox = null;
            activeEdit = null;
        }

        let scenes = {
            curScene:0,
            list:[
                {
                    id: "char", //id
                    nid: 0,     //number id
                    handler: {
                        // stats: health race class invent money mana spells
                        template:function (n="guy",h=3,mh=3,c="archer",r="human",m=10,ma=10,mma=10,i=[{id: "sword",}],s=[{id: "fireball",}]){
                            this.name= n,
                            this.health= h;
                            this.maxHealth= mh;
                            this.class= c;
                            this.race = r;
                            this.money= m;
                            this.mana= ma;
                            this.maxMana= mma;                         
                            this.inventory= i;
                            this.spells= s;
                        },
                        chars:[],
                        drawChar:function(x,y,char=new this.template,index){
                            push();
                            translate(x,y);
                            strokeWeight(3);
                            fill(200,200,250);
                            rect(0,0, 250, 625, 10)
                            line(0,70,250,70);
                            line(0,575,250,575);
                            fill(0,0,0);
                            textSize(50);
                            text(char.name, 10, 10, 240)

                            let h = 0; //keeps everything at the right height so nothing overlaps if its too long

                            function heart(x,y,size){
                                strokeWeight(2);
                                beginShape();
                                vertex(x, y);
                                bezierVertex(x - size / 2, y - size / 2, x - size, y + size / 3, x, y + size);
                                bezierVertex(x + size, y + size / 3, x + size / 2, y - size / 2, x, y);
                                endShape(CLOSE);
                            }

                            let row = 0;
                            for (let i = 0; i < char.health; i++){
                                if (i - (15*row) >= 15){
                                    row++;
                                }                                
                                fill(255,0,0);
                                heart((i*15) - (225*row) + 15, 80 + (15*row), 10 )
                            }
                            fill(0,0,0);
                            textSize(13);
                            stroke(0,0,0);
                            strokeWeight(1.25);
                            text(char.health + "/" + char.maxHealth, 7, 105 + (15*row))
                            h = 105 + (15*row) + 20;

                            fill(0,255,0)
                            ellipse(225,h+140,12,12)
                            line(222,h+140,228,h+140)
                            line(225,h+137,225,h+143)

                            fill(0);

                            textSize(17);
                            text("Race: "+ char.race, 7, h);
                            if (user.mX>=x+57&&user.mX<=x+87&&user.mY>=y+h-10&&user.mY<=y+h&&user.mC) {
                                startEditing(index,"race", x+70-window.scrollX, y+h-2-window.scrollY, 120, 20, char.race);
                            }
                            h+=20;
                            text("Class: "+ char.class, 7, h);
                            if (user.mX>=x+57&&user.mX<=x+87&&user.mY>=y+h-10&&user.mY<=y+h&&user.mC) {
                                startEditing(index,"class", x+70-window.scrollX, y+h-2-window.scrollY, 120, 20, char.class);
                            }


                            h+=20;
                            text("Mana: "+ char.mana + "/" + char.maxMana, 7, h);
                            if (user.mX>=x+57&&user.mX<=x+77&&user.mY>=y+h-0&&user.mY<=y+h+10&&user.mC) {
                                startEditing(index,"mana", x+70-window.scrollX, y+h-2-window.scrollY, 120, 20, char.mana);
                            }
                            if (user.mX>=x+85&&user.mX<=x+105&&user.mY>=y+h-0&&user.mY<=y+h+10&&user.mC) {
                                startEditing(index,"mana", x+70-window.scrollX, h-2-window.scrollY, 120, 20, char.mana);
                            }

                            h+=20;
                            text("Money: "+ char.money, 7, h);

                            h+=20;
                            text("Inventory: ", 7, h);
                            h+=10;
                            fill(150);
                            rect(10,h,230,150,5);
                            
                            fill(0,255,0)
                            ellipse(225,h+140,12,12)
                            line(222,h+140,228,h+140)
                            line(225,h+137,225,h+143)

                            fill(0);
                            h+=170;
                            text("Spells: ", 7, h);
                            h+=10;
                            fill(150);
                            rect(10,h,230,150,5);

                            fill(0,255,0)
                            ellipse(225,h+140,12,12)
                            line(222,h+140,228,h+140)
                            line(225,h+137,225,h+143)

                            fill(0);
                            textSize(12);
                            strokeWeight(0.5);
                            text("type here:", 5, 587);

                            fill(150);
                            strokeWeight(1.5);
                            rect(10,590,230,25,5)

                            pop();
                        },
                        draw: function(){
                            background(220);
                            let num = 0;
                            this.chars.forEach((char,i)=>{
                                this.drawChar((i * 300) + 75, 50, char, i);
                            })


                        },
                        update: function(){
                            if (this.chars.length <= 0){
                                this.chars.push(new this.template);
                                this.chars.push(new this.template);
                                this.chars.push(new this.template);
                                this.chars.push(new this.template);

                                let charCount = this.chars.length;
                                let neededWidth = charCount * 300 + 150; 
                                let neededHeight = 675; 

                                // Expand canvas horizontally if needed, but at least as wide as window
                                let finalWidth = Math.max(neededWidth, windowWidth);
                                let finalHeight = Math.max(neededHeight, windowHeight);

                                resizeCanvas(finalWidth, finalHeight);
                            }
                            
                        }
                    }
                },
            ],
            update: function (){
                let scene = this.list[this.curScene];
                scene.handler.draw();
                scene.handler.update();
            },
            swap: function (type, id) {
                if (type === "nid") {
                    this.curScene = id
                } else if (type === "id") {
                    this.list.forEach(e=>{
                        if (e.id === id){
                            this.curScene = e.nid
                        }
                    })
                }
            },
        };
        // ALWAYS END WITH MENU THEN USER
        function draw() {
            textAlign(LEFT, TOP);
            background(220);
            scenes.update();
            menu.update();    
            user.update();
        }

        function windowResized() {
            let scene = scenes.list[scenes.curScene];

            if (scene.id !== "char") {
                resizeCanvas(windowWidth, windowHeight);
            } else {
                // ✅ Calculate how wide canvas must be to fit all chars
                let charCount = scene.handler.chars.length;
                let neededWidth = charCount * 300 + 150; 
                let neededHeight = 675; 

                // Expand canvas horizontally if needed, but at least as wide as window
                let finalWidth = Math.max(neededWidth, windowWidth);
                let finalHeight = Math.max(neededHeight, windowHeight);

                resizeCanvas(finalWidth, finalHeight);
            }
        }
    </script>
</body>
</html>
